#!/usr/bin/python

#   Copyright 2016 Purdue University
#   
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#   
#       http://www.apache.org/licenses/LICENSE-2.0
#   
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
#   Filename:     run_regression.py
#
#   Created by:   John Skubic
#   Email:        jjs.skubic@gmail.com
#   Date Created: 07/06/2017
#   Description:  Script that will run a regression on all configurations.
#                 This should be used before pushing any finalized changes.


import argparse
import os
import sys
import yaml
import copy
import subprocess

TEMP_CONF = 'run_regression_cfg.yml'
TEMP_CONF_HEADER = '# THIS FILE IS AUTOMATICALLY GENERATED BY '
TEMP_CONF_HEADER += 'run_regression.py\n'
TEMP_CONF_HEADER += '# Do not attempt to modify this file.\n\n'

DIRS_IN_TOP = ['scripts','source_code','verification']

CC_PIPE = 'pipeline_config'
CC_CACHE_CFG = 'cache_config'
CC_CACHE = 'cache_type'
CC_BR_PRED = 'br_predictor_type'
CC_RMGMT  = 'risc_mgmt_params'

CACHE_SEPARATE = 'separate'
CACHE_UNIFIED = 'unified'

FORMAT_ASM = 'asm'
FORMAT_SELF_ASM = 'selfasm'
FORMAT_SELF_C = 'c'

ARCH_RV32I = 'RV32I'
ARCH_RV32M = 'RV32M'
ARCH_CUST  = 'NONSTANDARD'

RMGMT_STANDARD = 'standard_extensions'
RMGMT_NONSTANDARD = 'nonstandard_extensions'

RMGMT_ENCODING_RTYPE = 'R_TYPE'
  
CFG_ENUM_LIN = 'enum_linear'
CFG_ENUM_EXHAUSTIVE = 'enum_exhaustive'

# configurations affective runtime
MAX_NUM_EXTS = 2
CFG_ENUM_MODE = 'enum_exhaustive' 

# output locations
SIM_OUT_DIR = 'sim_out'
CFGS_OUT = 'regress_failures'
CFG_FILENAME = 'cfg.yml'
LOG_FILENAME = 'output.log'

class ConfigurableComponent(object):
  def __init__(self, name, formats, test_str, archs, cc_type):
    self.name = name
    self.test_formats = formats
    self.test_str = test_str
    self.archs = archs
    self.cc_type = cc_type

class RMGMTExtension(ConfigurableComponent):
  def __init__(self, name, formats, test_str, archs, cc_type, ext_type, encoding, length):
    super(RMGMTExtension, self).__init__(name, formats, test_str, archs, cc_type)
    self.ext_type = ext_type
    self.encoding = encoding
    self.length = length

'''
  Simple check to make sure the script is being run from the 
  top level directory of RISCVBusiness
'''
def check_dir():
  files = os.listdir('./')
  for path in DIRS_IN_TOP:
    if not path in files:
      return False
  return True  

def generate_ext_combos(ext_list, max_exts):
  counters = [0] * (max_exts+1)
  num_exts = len(ext_list)
  cnt_rollover = num_exts+1 #+1 for option to not choose an ext
  configs = []

  while (counters[max_exts] != 1):
    #add the new config
    config = []
    for i in range(max_exts):
      if counters[i] < num_exts:
        if not (ext_list[counters[i]] in config):
          config.append(ext_list[counters[i]])
    config.sort(key=lambda x: x.name, reverse=True)
    if not (config in configs):
      configs.append(config)
    #update counters
    counters[0] += 1
    i = 0
    while (i <= max_exts) and (counters[i] == cnt_rollover):
      counters[i] = 0
      i += 1
      if i <= max_exts:
        counters[i] += 1
  return configs

'''
  returns a string of yaml code representing the configuration 
  that can be fed to the configure core script for the chosen
  configurations.

  Returns a string containing the yml for the current config.
'''
def get_yaml_from_cfgs(branch_cfg, cache_cfg, rmgmt_cfg):
  base_cfgs = {'isa_params':{'xlen':'32'}}
  
  microarch_cfgs = {'br_predictor_type' : branch_cfg[0].name,
                    'bus_endianness' : 'big',
                    'bus_interface_type' : 'generic_bus_if'}
  microarch_cfgs['cache_config'] = cache_cfg[0].name
  if cache_cfg[0].name == CACHE_SEPARATE:
    microarch_cfgs['dcache_type'] = cache_cfg[1].name
    microarch_cfgs['icache_type'] = cache_cfg[2].name
  else: #unified
    microarch_cfgs['cache_type'] = cache_cfg[1].name
  
  risc_mgmt_params = {RMGMT_STANDARD:[],
                      RMGMT_NONSTANDARD:[]}
  for ext in rmgmt_cfg:
    if ext.ext_type == RMGMT_STANDARD:
      risc_mgmt_params[RMGMT_STANDARD].append({'name' : ext.name})
    else:
      risc_mgmt_params[RMGMT_NONSTANDARD].append(
        {'name' : ext.name,
        'encoding' : ext.encoding,
        'length' : ext.length})

  if len(risc_mgmt_params[RMGMT_STANDARD]) == 0:
    risc_mgmt_params.pop(RMGMT_STANDARD, None)
  if len(risc_mgmt_params[RMGMT_NONSTANDARD]) == 0:
    risc_mgmt_params.pop(RMGMT_NONSTANDARD, None)

  final_cfgs = copy.deepcopy(base_cfgs)
  final_cfgs['microarch_params'] = microarch_cfgs
  if len(rmgmt_cfg) > 0:  
    final_cfgs['risc_mgmt_params'] = risc_mgmt_params  
  return yaml.safe_dump(final_cfgs, default_flow_style=False)

'''
  Gets the arguments for running the run_tests.py script.
  Decides which test types should pass and what
  architectures should be tested.

  Returns a tuple of:
    1) valid test types
    2) Tuple of architechtures and test string
'''
def get_args_from_cfgs(branch_cfg, cache_cfg, rmgmt_cfg):
  cfgs = branch_cfg + cache_cfg + rmgmt_cfg
  # test types is the intersection of all cfgs
  test_types = [FORMAT_ASM, FORMAT_SELF_ASM, FORMAT_SELF_C]
  # architectures are the union of all cfgs
  archs = []
  for cfg in cfgs:
    if cfg.cc_type != CC_RMGMT:
      for tt in test_types:
        if not (tt in cfg.test_formats):
          test_types.remove(tt)
    for arch in cfg.archs:
      i = 0
      while i<len(archs) and archs[i][0] != arch:
         i+=1
      if i == len(archs):
        archs.append([arch, [cfg.test_str]])
      else:
        if archs[i][1][0] != "":
          if cfg.test_str == "":
            archs[i][1] = [""]
          else:
            archs[i][1].append(cfg.test_str)
  return (test_types, archs)
  

'''
  Runs the tests for the current configuration.
  On a failure, the run_tests output will be dumped to a file and
  the yml configuration file will be saved.
  
  Returns true or false depending on the results of the test.
'''
def run_test(yml, test_types, archs, test_id):
  # Dump Yaml to file
  try:
    fptr = open(TEMP_CONF, 'w')
    fptr.write(TEMP_CONF_HEADER)
    fptr.write(yml)
    fptr.close() 
  except:
    print "Couldn't create file %s" % (TEMP_CONF)
    return False
  
  # Run Tests
  for test in test_types:
    for arch in archs:
      run_cmd = ["./run_tests.py", "--test", str(test), "--arch", str(arch[0]), str(arch[1])]
      p = subprocess.Popen(run_cmd, stdout=subprocess.PIPE, 
                            stderr=subprocess.PIPE, shell=True)
      out, err = p.communicate()
      if err != "" or "FAILED" in out: 
        print "The command %s failed!" % (run_cmd)
        return False
  print "Configuration Passed" 
  return True

if __name__ == "__main__":
  description =  "Runs a regression by testing each configuration." 
  parser = argparse.ArgumentParser(description=description)
  args = parser.parse_args()

  if not check_dir():
    err_msg = "Please try running this script from the top level"
    err_msg += " RISCVBusiness directory."
    sys.exit(err_msg)

  ''' Different Components that can be chosen '''
  branch_comps = []
  cache_comps = []
  cache_cfg_comps = []
  rmgmt_exts = []

  ''' Valid Configurations for each component '''
  cache_cfgs = []
  branch_cfgs = []
  rmgmt_cfgs = []

  ''' Add Components to their respective lists '''

  #############################################
  # Add Branch Predictors                     #
  #############################################

  branch_comps.append(ConfigurableComponent(
    'not_taken',
    [FORMAT_ASM, FORMAT_SELF_ASM, FORMAT_SELF_C],
    '',
    [ARCH_RV32I],
    CC_BR_PRED
  ))

  #############################################
  # Add Caches                                #
  #############################################

  cache_cfg_comps.append(ConfigurableComponent(
    'separate',
    [FORMAT_ASM, FORMAT_SELF_ASM, FORMAT_SELF_C],
    '',
    [ARCH_RV32I],
    CC_CACHE_CFG
  ))

  cache_comps.append(ConfigurableComponent(
    'pass_through',
    [FORMAT_ASM, FORMAT_SELF_ASM, FORMAT_SELF_C],
    '',
    [ARCH_RV32I],
    CC_CACHE
  ))

  cache_comps.append(ConfigurableComponent(
    'direct_mapped_tpf',
    [FORMAT_SELF_ASM, FORMAT_SELF_C],
    '',
    [ARCH_RV32I],
    CC_CACHE
  ))

  #############################################
  # Add RISC-MGMT Extensions                  #
  #############################################

  rmgmt_exts.append(RMGMTExtension(
    'rv32m',
    [FORMAT_ASM, FORMAT_SELF_ASM, FORMAT_SELF_C],
    '',
    [ARCH_RV32M],
    CC_RMGMT,
    RMGMT_STANDARD,
    RMGMT_ENCODING_RTYPE,
    0 
  ))
  
  rmgmt_exts.append(RMGMTExtension(
    'crc32',
    [FORMAT_SELF_C],
    'crc32',
    [ARCH_CUST],
    CC_RMGMT,
    RMGMT_NONSTANDARD,
    RMGMT_ENCODING_RTYPE,
    2 
  ))

  ''' Generate different configurations based on components.
      Configuration yml files can be directly generated from 
      choosing a configuration from each list '''

  # Generate branch configs

  for comp in branch_comps:
    branch_cfgs.append([comp])

  # Generate cache configs

  for cfg_comp in cache_cfg_comps:
    if cfg_comp.name == CACHE_SEPARATE: # generate i & d $
      for dcache in cache_comps:
        for icache in cache_comps:
          cache_cfgs.append([cfg_comp, dcache, icache])
    elif cfg_comp.name == CACHE_UNIFIED: # generate single cache
      for cache in cache_comps:
        cache_cfgs.append([cfg_comp, cache])

  # Generate RMGMT Extensions
  rmgmt_cfgs = generate_ext_combos(rmgmt_exts, MAX_NUM_EXTS)

  # eval num cfgs
  num_cfgs = len(cache_cfgs) * len(rmgmt_cfgs) * len(branch_cfgs)
  
  # Generate final configurations for testing

  ''' Exhaustive will enumerate through every possible
      combination of configurations and run full tests on
      each configuration.  
      Note this may take an extensive amount of time.

      Linear will guarantee every configurable component is 
      tested at least once.  This feature is not yet supported.
  '''
  test_cnt = 0
  test_fails = 0

  if CFG_ENUM_MODE == CFG_ENUM_EXHAUSTIVE:
    print "Testing %d configurations." % (num_cfgs)  
    for branch_cfg in branch_cfgs:
      for cache_cfg in cache_cfgs:
        for rmgmt_cfg in rmgmt_cfgs:
          cfg_yaml = get_yaml_from_cfgs(branch_cfg, cache_cfg, rmgmt_cfg)
          cfg_args = get_args_from_cfgs(branch_cfg, cache_cfg, rmgmt_cfg)
          result = run_test(cfg_yaml, cfg_args[0], cfg_args[1], test_cnt) 
          if not result: 
            test_fails += 1
          test_cnt += 1
  elif CFG_ENUM_MODE == CFG_ENUM_LINEAR:
    #TODO: Implement linear configuration
    print "Linear configuration test mode not yet supported"
    pass
  else:
    pass

  print "%d test(s) failed out of %d" % (test_fails, test_cnt)
  if test_fails == 0:
    print "REGRESSION PASSED"
  else:
    print "REGRESSION FAILED"
